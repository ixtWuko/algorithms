\section{基础知识}
\subsubsection*{渐进记号}
\begin{itemize}
    \item $\Theta$: $f(n) = cg(n)$
    \item $O$: $f(n) \le cg(n)$
    \item $o$: $f(n) < cg(n)$
    \item $\Omega$: $f(n) \ge cg(n)$
    \item $\omega$: $f(n) > cg(n)$
\end{itemize}
本笔记中未说明的，为最坏情况运行时间和期望运行时间相同。其中的$\log n$为$\log _2 n$

\subsubsection*{求解递归式}
递归式用于分析分治算法的运行时间。
\begin{itemize}
    \item 代入法：猜测一个界，然后验证。
    \item 递归树法：将递归式转换为一棵树，求和。
    \item 主方法：使用主定理

    若递归式$T(n) = aT(n/b) + f(n)$中，$a \ge 0, b > 0$，则比较$f(n)$与$n^{\log _b a}$，
    \begin{itemize}
        \item $f(n) > n^{\log _b a}$, $T(n) = \Theta (n^{\log _b a})$.
        \item $f(n) < n^{\log _b a}$, $T(n) = \Theta (f(n))$.
        \item $f(n) = n^{\log _b a}$, $T(n) = \Theta (n^{\log _b a} \log _2 n)$.
    \end{itemize}

    另外还有 Akra-Bazzi 方法。
\end{itemize}

\subsubsection*{概率分析}
概率分析用于分析随机算法的运行时间。

指示器随机变量：$I\{A\} = \begin{cases} 1 & A \text{发生}\\ 0 & A \text{不发生} \end{cases}$

\begin{itemize}
    \item 对于一次事件：$E(I\{A\}) = 1 \cdot P(A) + 0 \cdot P(\overline A) = P(A)$
    \item 对于$n$次事件：$E(X) = E(\displaystyle \sum _{i=1}^n X_i) = \sum _{i=1}^n E(I\{A_i\}) = \sum _{i=1}^n P(A_i)$
\end{itemize}

产生一个均匀随机序列：指能够等可能地产生包含所有元素的每一种序列的方式，随机产生的一个序列。

\section{数据结构}

\section{搜索}
\begin{itemize}
    \item 线性搜索 linear search: 在无序的序列上使用，运行时间$O (n)$.
    \item 随机搜索 random search: 在无序的序列上使用，运行时间$O (n)$.
    \item 二分搜索 binary search: 只能在有顺序的序列上使用，运行时间$O (\log n)$.
\end{itemize}

\section{排序}
\begin{itemize}
    \item 选择排序 selection sort: $\Theta (n^2)$

    依次从未排序的数列中取出最小元素，放入排好的序列的最后。

    \item 插入排序 insertion sort: $\Theta (n^2)$

    依次从未排序的数列中的取出元素，插入到排好的序列中的合适位置。

    \item 冒泡排序 bubble sort: $\Theta (n^2)$

    依次比较未排序的数列中相邻的两个元素，若不符合前小后大，则交换两个元素的位置，经过一遍比较会将最大的元素移动到数列的最后，形成已排好的序列。重复上述步骤，比较的次数为$n-1, n-2, \cdots, 1$。

    \item 归并排序 merge sort: $\Theta (n \log n)$

    将未排序的数列分成两个部分进行排序，再从两个部分中依次取出元素，按大小顺序合并。被分开的两个数列进行递归排序。

    \item 堆排序 heap sort: 最坏情况运行时间$O (n \log n)$

    堆是一个完全二叉树（也可以缺失最后一个树叶）。使用一个数组来表示堆这种数据结构：将二叉树每一层的元素从左向右排列，从第0层到最后一层依次放入数组。
    \[ [ \text{root}, \text{first level}, \text{second level}, \cdots ]\]
    若数组编号从1开始，对于位于数组中$index$的节点，其父节点位于$index / 2$，其左子节点位于$2 \cdot index$, 其右子节点位于$2 \cdot index + 1$.

    堆排序使用的是最大堆或最小堆。最大堆中所有的父节点都大于等于子节点，最小堆中所有的父节点都小于等于子节点。

    在最大堆中的根是所有元素中最大的，将该元素取出，放入已排好的序列，然后将剩余的元素恢复最大堆的性质。重复取出根和恢复最大堆性质的过程，就是堆排序的过程。

    恢复最大堆性质是将某个可能不符合的节点与其两个子节点比较，若其某个子节点更大，则交换该节点和更大的子节点，同时对被交换的子节点递归调用此步骤。对堆中的所有内点使用恢复最大堆性质这一过程，可以从一个无序数列中构建一个最大堆。

    \uline{优先队列}：使用最大堆可以构建优先队列，其可以插入元素，但是只能弹出当前状态中的最大元素。

    \item 快速排序 quick sort: 最坏情况运行时间$\Theta (n^2)$，期望运行时间$\Theta (n \log n)$.

    从未排序的数列中选择一个元素作为中间值，将数列分成两个部分，其中左部分中元素小于中间值，右部分元素大于等于中间值。递归地进行此操作，可以的到排好的数列。
\end{itemize}

\subsubsection*{针对特殊数列的排序}
\begin{itemize}
    \item 计数排序 counting sort: $\Theta (k+n)$，$k$为计数范围。

    计数排序针对数列中的整数的范围已知且不大时的排序，通过统计每个整数出现的次数获得整数应该出现的位置，如第$i$大的整数，应该处于排好的序列的第$j$个位置，其中$j$为比该整数小的所有整数出现次数的和加一。

    \item 基数排序 radix sort：$\Theta (d(n+k))$，$d$为位数。

    基数排序针对数列中所有的整数的位数已知时的排序，使用其它的稳定的排序算法（比如计数排序），首先以这些整数的最低位作为依据排序，然后是次低位，以此类推至最高位。

    基数排序也可以用于英文单词的排序。

    \item 桶排序 bucket sort: 最坏情况运行时间$\Theta (n^2)$，期望运行时间$\Theta (n)$

    桶排序将未排序的数列中元素的范围划分成$n$个大小相同的区间，称为桶，然后将所有元素都放入桶中。桶内的排序使用其它的排序算法，排序完成后，组合成排好的序列。

    桶排序除了桶内的排序，其它的运行时间为$O(n)$，总体的运行时间依赖于桶内的排序算法。
\end{itemize}